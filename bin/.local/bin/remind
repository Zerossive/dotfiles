#!/usr/bin/env bash
# ==============================================================================
# Script Name: remind
# Description: At some specific time, sends out a notification.
# Usage: remind [options] <time> <message>
# Author: Danny Harris
# Dependencies: at, kdeconnect-cli, paplay, notify-send
# ==============================================================================

show_help() {
	local cmd="${0##*/}"
	cat <<-EOF
		Sends out a notification at a specific time.

		Usage: $cmd [options] <time> <message>

		Options:
		  -l, ls                list active reminders
		  -r ID..., rm ID...    remove specific reminders
		  -a, rma               remove all reminders

		Examples:
		  $cmd now+1hour complete this task
		  $cmd 10amtomorrow complete this other task
		  $cmd rm 1 2 3 4 5
	EOF
}

# dependency checks
dependencies=(at notify-send)
for cmd in "${dependencies[@]}"; do
	if ! command -v "$cmd" >/dev/null 2>&1; then
		printf "error: '%s' command does not exist\n" "$cmd" >&2
		exit 1
	fi
done

notify() {
	local time="$1"
	local message="$2"

	# check for `notify-all` command
	if ! command -v notify-all >/dev/null 2>&1; then
		printf 'error: notify-all does not exist, running notify-send instead\n' >&2
		at "$time" <<<"notify-send --app-name='notify-all' --icon='clock' -t 5000 --urgency='urgent' '$message'; curl -sd '$message' -H 'Title: ⌛ REMIND' -H 'Priority: high' olympus:8234/alerts >/dev/null"
		exit 0
	fi

	at "$time" <<<"notify-all -u 2 -t '⌛ REMIND' $message"
}

# delete everything after the first tab (keep id)
parse_id() {
	printf "%s\n" "${*%%$'\t'*}"
}

parse_date() {
	local date="${*% * *}"
	date="${date#*$'\t'}"
	date="$(date '+%Y-%m-%d|%H:%M|%-I:%M %p' -d "$date")"
	printf "%s\n" "$date"
}

parse_script() {
	printf "%s\n" "$(at -c "$*" | sed -e '1,/SHELL:-/d' -e '$d' -e "s/^.*REMIND' //")"
}

main() {
	# List active reminders
	if [[ "$1" == "ls" || "$1" == "-l" ]]; then
		mapfile -t reminders_raw < <(atq)
		local id date script
		local reminders_sorted=()
		for reminder in "${reminders_raw[@]}"; do
			id="$(parse_id "$reminder")"
			date="$(parse_date "$reminder")"
			script="$(parse_script "$id")"
			reminders_sorted+=("$date|[$id]|$script")
		done
		mapfile -t reminders_sorted < <(printf "%s\n" "${reminders_sorted[@]}" | sort)
		printf "%s\n" "$(printf "%s\n" "${reminders_sorted[@]}" | sort | column -t -s '|')"
		exit 0
	fi

	# delete specific reminders
	if [[ "$1" == "rm" || "$1" == "-r" ]]; then
		shift
		local ids_to_remove=("$@")
		for id in "${ids_to_remove[@]}"; do
			atrm "$id" &&
				printf 'Removed: %s\n' "$id"
		done
		exit 0
	fi

	# Delete all reminders
	if [[ $# -eq 1 && ("$1" == "rma" || "$1" == "-a") ]]; then
		local confirmation
		read -r -n 1 -p 'Delete all reminders? [y/N] ' confirmation
		printf "\n"
		if [[ "$confirmation" =~ ^[Yy]$ ]]; then
			mapfile -t reminders < <(atq)
			local id date script
			for reminder in "${reminders[@]}"; do
				id="$(parse_id "$reminder")"
				date="$(parse_date "$reminder")"
				script="$(parse_script "$id")"

				atrm "$id" &&
					printf "Removed: %s\n" "$date|[$id]|$script" | column -t -s '|'
			done
		else
			printf "Deletion canceled.\n"
		fi
		exit 0
	fi

	# Initialize arguments
	local time="$1"
	shift
	local message="$*"

	# Check for valid arguments
	if [[ -z "$message" ]]; then
		show_help
		return 1
	fi

	# send notifications
	notify "$time" "$message"
}

main "$@"

# vim: set ft=sh:
